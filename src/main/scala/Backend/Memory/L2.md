## 重要信号

### [存储]

1. Tag表：4路，双端口可读写
   1. 端口1
      1. 地址：fsm的addrOH控制，Refill时选s3[写tag]，wait1时选s2[惨遭阻塞]，其余时候选s1
      2. 写数据：选s3的paddr[写tag]
      3. 写使能：只能写0-1路，fsm根据lru指示写which路
   2. 端口2：同端口1，区别是只能写2-3路
2. data表：4路，双端口可读写
   1. I端口
      1. 地址：同tag表端口1
      2. 写数据：rbufC1
      3. 写使能：只能写0-1路，将其字节化[Refill时填充整个cacheline]
   2. D端口
      1. 地址同上
      2. 写数据：
         1. 写命中：将wdata移位到对应字节偏移的比特位[例如偏移是64Byte，则制作数据{60B_0,4B,64B_0}]
         2. Refill：wdataRbuf
      3. 写使能：
         1. 写命中：将mtype移位到对应字节偏移的比特位[例如偏移是64Byte，写4B，则写使能{60b_0,4b,64b_0}]
         2. Refill：只能写2-3路，将其字节化[Refill时填充整个cacheline]
3. valid表：4路，双端口可读写异步
   1. 值得注意的就是，D channel可能会作废0-1路
4. lru表：2个，一读一写
   1. I
      1. 读地址：同D
   2. D
      1. 读地址：s3 paddr index
      2. 写使能：命中时 / Refill时
      3. 写数据：miss1 hit0 /  取反

---
1. rbufC1
   1. 用途：主存读数据的缓存
   2. 大小：长度128(line width)*8bits
   3. 时序：32bits右移的移位器
   4. 高位：主存读的32bits字；低位：rbuf右移32bits字
   5. 主存读完整个cacheline的周期，rbufC1 = cacheline
2. rbufC2：同rbufC1
3. wbufC2
   1. 用途：
4. wdataRbuf：s3数据 mask 主存读数据

### [接口]

主存读：miss / uncache_load
1. 地址：line地址 / 字地址
2. 突发数：32(字) / 1(字)
3. 数据size：4(B) / mtype 

主存写：replace / uncache_store
1. 地址：line地址 / 字地址
2. 数据： line 0->31 字 / {TODO}
3. 字节掩码：1111 / mtype与paddr字节确定 
4. 突发数：32(字) / 1(字)

## Case

### 1. ICache读

1. 命中：正常走1 2 3级流水，第三级返回 hit的line[需要拆出L1的line]
2. 缺失：阻塞在第3级，[读主存] -> 返回rbufC1[拆]给L1; refill L2 cacheline(data tag valid)
   1. 由于icache对应的两路不脏，所以无需替换写回主存
3. uncache：阻塞在第三级，[读主存] -> 高位填0，低位是从主存读过来的一个字；无需Refill


### 2. DCache读

1. 命中：正常走1 2 3级流水，第三级返回 hit的line[需要拆出L1的line]
2. 缺失：阻塞在第3级，[读主存] -> 返回rbufC1[拆]给L1; refill L2 cacheline(data tag valid)
   1. 由于dcache对应的两路会脏，所以refill时可能需要往主存写，这里有一个自动机维护向主存写
3. uncache：阻塞在第三级，[读主存] -> 高位填0，低位是从主存读过来的一个字；无需Refill

### 3. DCache写

1. 命中：正常走1 2 3级流水，第三级会用wdata wmask写入cache line，写脏位；
2. 缺失：阻塞在第3级，读完主存 -> refill L2 cacheline(data tag valid)
   1. 写数据是 s3数据 mask 主存读数据
3. uncache：阻塞在第3级，有一个自动机维护向主存写


