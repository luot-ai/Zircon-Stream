## 没必要加的一条指令

原以为b数组的tilestride还要再配置一个东西：假设buffer X > gemm_k，应该在gemm_k时来到下一列（目前是直接在buffer X来到下一列）
**但其实NV 的tensor指令里K就是固定值！**
也就是说我们允许的算子的gemm_k就是buffer 半区的大小

## 连L2而不是L1

之前以为不连L1可能会造成一致性问题，但其实一致性的关键在于**流Engine写的数据若不经过L1而到达更低存储层级，那么要确保这个数据不会被用**

实际上，就算是在FFT中，按照之前的设想，流Engine可能会读由普通指令store的数据，**这里根本不用担心如果连L2，那L1有更新的怎么办这个问题，因为L1是写直达，L1不会比L2新**

因此，直连L2就可以，没必要把数据在L1中倒腾

## 1. stream engine 内部load流水线更新逻辑（适配L1）
```scala
/*
    若in.ready
        该级更新为上一级（若上一级out.valid）
        或0（若上一级不out.valid）
    否则若out.ready，则该级更新为0
    否则(in out都不ready)保持不变

    out.valid := valid && readyGo
    假设我们本级不valid时，总是0，则out.valid 就是readyGo

    in.ready := !valid || (out.ready && readyGo)
    !valid可以被省略，这样的话 当out不ready时，即使该级无数据，也不允许更新（没啥损失可能）
    所以 in.ready := out.ready && readyGo

    在LSPP中，只有D2可能不readyGo，而D2的out.ready恒1
        因此对于D2，in.ready = readyGo(!miss && !sbFull)
        对于其他各级 in.ready=out.ready，也等于(!miss || !sbFull)
    在SELDPP中，D2可能不readyGo，RF也可能不readyGo
        D2的readyGo = !miss && !sbFull
        RF的readyGo = !lsuRfValid
    因此，各级的in.ready是这样
        D2：!miss && !sbFull
        D1：!miss && !sbFull 
        RF：!miss && !sbFull && !lsuRfValid
    各级的out.valid是这样
        D2：!miss && !sbFull
        D1：1
        RF：!lsuRfValid
*/
```

## 2. 流计算指令如何获得index
index cnt是一个体系结构状态
   1. 循环变量作为**流计算指令**源操作数：几乎不可行，因为RF级时序紧张
      1. 循环变量i存放在通用寄存器中
      2. 数据相关：通用寄存器相关
      3. 可以处理`部分消耗`
   2. 循环变量不作为**流计算指令**源操作数
      1. 循环变量i存放在硬件寄存器中
      2. 需要额外维护 `step/流计算指令(修改i) -> 流计算指令(使用i)` 的数据相关
         1. 对耦合在流水线的方案也**并没有特别不友好** 
            1. 多发射alu
            2. 待发射指令需要检查在流水线中未改变硬件iter cnt的指令
      3. 方案
         1. 使用step指令
            1. 显示递增计数器
            2. 可以处理`部分消耗`
            3. **可在前端处理这条指令**
            4. 浪费指令数量
         2. 不使用step指令
            1. 由流计算指令驱动计数器递增
            2. 只能处理`完全消耗`