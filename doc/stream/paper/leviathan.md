# micro-24

## 摘要/介绍/背景

亮点：NDC分类法；性能和能耗都降低

强调他人设计的弊病：
1. 未综合各领域
2. 仅针对设计空间中的有限子集
3. 与微架构耦合有一些严重

作者的设计：
1. 响应式编程接口
2. 在cache部署计算引擎
3. 多态cache层次结构

划分了四类：
作者认为它的actor模型可以更好的统一这四类模型

TODO：branch1：数据移动加速器


非常好，这一节（**Section III: Leviathan Overview**）是整篇论文的**核心设计总览**，它正式介绍了 Leviathan 的目标、接口模型、以及硬件实现思路。下面我帮你分段详细翻译与总结👇

---

## 🧭 第三章：Leviathan 概述（Overview）

---

### 🎯 **总体目标**

Leviathan 的目标是：

> **提供一个多态（polymorphic）的缓存层次结构**，
> 能够**统一支持所有现有的近数据计算（NDC）范式**，
> 同时保持**易于编程**。

---

Leviathan 的出发点与现有可编程 NDC 系统一样（如 [6, 11, 47, 54, 66, 79, 81, 90]）：

* 在多核体系结构中，**在缓存银行（cache banks）旁边加入通用的可编程计算单元**；
* 让软件可以在“靠近数据”的位置执行任意计算。

但 **Leviathan 更进一步**：

* 增加微架构支持，使得**系统能在正确的时间和地点执行任务**；
* 向程序员暴露统一接口，**隐藏底层细节**（如缓存行划分、bank 分布等）。

---

### 💻 **编程接口（Programming Interface）**

Leviathan 提供两层接口：

1. **面向对象的内存分配器（object-oriented allocator）**
   用于创建数据对象（actor）并保证：

   > 对象的所有数据都位于同一个缓存银行（intra-bank locality）。

2. **基于 Actor 的接口（actor-based interface）**
   每种 NDC 范式（任务下放、长期任务、数据触发、流式计算）都以 **Actor** 的形式操作。

   程序员只需要指定：

   * **要执行的动作（what）**
   * **使用的范式（which paradigm）**

   而：

   * **何时执行（when）**
   * **在哪里执行（where）**
     则由 **Leviathan 的运行时和硬件支持自动决定**。

---

### 🧩 **四种范式在 Leviathan 中的对应实现**

| NDC 范式                  | 动作（Action）                          | 触发机制                      | 执行位置             | 特点             |
| ----------------------- | ----------------------------------- | ------------------------- | ---------------- | -------------- |
| **Task Offload**        | 核心或其他 Actor 显式触发的任务                 | 显式调用                      | 指定缓存层            | 快速、轻量的操作（如原子加） |
| **Long-lived Workload** | 常驻任务                                | 显式触发但持续运行                 | 固定层（LLC或MemCtrl） | 后台运行、处理大数据     |
| **Data-triggered**      | 构造器 / 析构器（constructor / destructor） | 当数据插入或逐出缓存时触发             | 缓存层              | 类似预取、压缩        |
| **Streaming**           | Producer + Consumer                 | Producer 推送数据、Consumer 消费 | 不同核间             | 双向通信、解耦访问      |

> 💡 程序员只写「动作函数」和「使用的范式」，Leviathan 自动处理触发逻辑与数据位置。

---

### ⚙️ **硬件结构（Hardware Overview）**

Leviathan 的硬件基于一个**标准的多核、缓存一致性架构**（cache-coherent multicore），在此基础上进行增强：

1. **每个 Tile 增加一个近数据引擎（Near-Data Engine）**

   * 内含一个轻量级可编程处理器（programmable processor），执行应用定义的动作；
   * 不同范式的主要区别是**动作的触发方式不同**；
   * 触发逻辑由**硬件调度器（hardware scheduler）**实现。

2. **引擎的关键组成部分**：

   * **轻量级处理单元（programmable processor）**：执行 NDC 动作；
   * **小型一致缓存（coherent cache）**：与主缓存层协同；
   * **任务上下文缓冲区（task-context buffer）**：管理正在执行的 actor 状态；
   * 以及少量对核心和缓存的微调支持。

---

## 🧠 总结与分析

| 层次    | 模块                 | 功能         | 说明         |
| ----- | ------------------ | ---------- | ---------- |
| 软件接口  | 面向对象分配器 + Actor 模型 | 抽象出可编程数据对象 | 自动保证局部性    |
| 程序模型  | “What + Paradigm”  | 程序员只声明意图   | 时间与位置自动决定  |
| 硬件层   | 近数据引擎 (NDE)        | 在缓存旁执行动作   | 统一四种范式触发逻辑 |
| 微架构支持 | 调度器 + 本地缓存 + 上下文管理 | 精确控制动作触发时机 | 支持多范式并发    |

---

### 📊 小结一句话：

> **Leviathan 把“近数据计算”抽象为 Actor 对象的动作触发问题。**
>
> 程序员只定义「做什么」和「用哪种模式」，系统自动决定「何时、何地执行」；
> 硬件上，每个缓存 bank 配备轻量可编程引擎，通过统一调度机制支持所有范式。

---

如果你准备开始**细读设计章节（第4~6章）**，这一节其实就是总览地图。
我建议接下来：

* **先读 Fig. 1（系统结构）与 Fig. 2（actor 伪代码）**，理解运行机制；
* 然后按论文顺序读 **Section IV~V（系统映射与调度）**；
* 最后看 **Section VI（评估案例）**，对应回上文中的四种范式。

---

